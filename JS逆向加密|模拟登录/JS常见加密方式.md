### js常见加密方式
#### md5
	- 广泛使用线性散列算法，产生128位（16字节）的散列值（hash value），用于确保传输完整的一致性，且MD5加密后产生的是一个固定长度（32位或16位）的数据  
	- 解密
		一般来说MD5不存在解密，但理论上可以进行逆向暴力破解，破解原理是用很多不同的数据进行加密后跟已有的加密的数据进行对比，由此找到规律，理论上只要样本足够多就越容易破解。
	- 增加破解成本（常用方法）
		1. 使用无意义且随机私钥进行MD5加密，生成加密串1；
		2. 将要加密的数据跟串1拼接，再进行一次MD5加密，生成加密串2；
		3. 将加密串2进行MD5加密，生成加密串3
#### DES/AES
	- 全称Data Encryption Standard，即数据加密标准，是一种使用密钥加密的算法。该加密算法是一种对称加密方式，其加密运算、解密运算需要使用的是同样的密钥
	- 注意
		- AED标准已替代原先的DES
		- AES和DES的区别：
			- DES密文长度是8的整数倍
			- AES密文长度是16的整数倍
			- 企业级开发使用DES足够安全
			- AES适合更高要求
		- DES和AES切换只需要修改CrayptoJS.AES <=> CrayptoJS.DES
	- 破解方法
		- 暴力破解
		- DES如果使用56位密钥，则可能的密钥数量是2的56次方个，算力充足的情况下是可以破解的
	- DES算法的入口参数
		- Key为7个字节共56位，是DES算法的工作密钥
		- Data为8个字节64位，是要被加密或被解密的数据
		- Mode为DES的工作方式
		- padding为填充模式，如果加密后密文长度达不到指定整数倍（8个字节、16个字节），填充相应的字符（padding的赋值固定为CryptoJS.pad.Pkcs7即可）
#### RSA
	- 一种非对称加密算法，在公开密钥加密和电子商业中广泛应用
	- 非对称加密算法需要两个密钥
		- 公钥和私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密，因为加密和解密使用的是两个不同的密钥，所以叫非对称加密算法
	- 注意：
		- 使用时都是使用公钥加密使用私钥解密，公钥可以公开
		- 算法强度复杂、安全性依赖于算法与密钥，但使得加密解密速度没有对称加密速度快
#### base64
	- 使用64个字符来表示任意二进制数据的方法，base64是一种编码方式也叫伪加密
	- 使用A-Z，a-z，0-9，+，/这64个字符
#### https
	- 在http传输中对传输数据进行加密
	- 请求和响应过程（对称加密）
		1. 客户端使用密钥对请求进行加密，并发送给服务端
		2. 服务端接受到密文后，使用密钥对密文进行解密，然后处理请求，最后再使用密钥把要返回的内容再次加密，返回给客户端
		3. 客户端接收到密文之后，使用对称密钥进行解密，并获取最终的响应内容
	- 请求和响应过程（非对称加密）
		1. 服务端创建一对公钥、私钥
		2. 客户端向服务端发送请求获取公钥
		3. 服务端把公钥返回给客户端
		4. 服务端获取公钥
		5. 内部创建一个随机字符来做对称密钥
		6. 使用公钥对对称密码（随机字符串）加密，并发送给服务端
		7. 接收密码并公钥解密，获取对称密钥
		8. 服务端Finished报文（双方都获得了密钥）
		9. 使用对称密钥对发送的数据加密（发送数据）
		10. 接收数据并使用非对称密钥进行解密
		11. 使用对称密钥对响应数据加密（响应数据）
		12. 使用对称密钥对数据机密
		//如果在步骤2和步骤6被黑客劫持那么加密将会无效
	- 证书加密
		1. 浏览器将自己支持的一套加密规则发送给网站。 
		2. 网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。  
		3. 浏览器获得网站证书之后浏览器要做以下工作： 
			1. 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。 
			2. 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。 
			3. 使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。 
		 4. 网站接收浏览器发来的数据之后要做以下的操作： 
		 	1. 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。 
		 	2. 使用密码加密一段握手消息，发送给浏览器。 
		 5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。 
